<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Turning Demucs into a Web-API</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Ubuntu:ital,wght@0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css" />
    <title>Web Application Performance: Server-Side and Client-Side Optimization</title>
</head>
<body>
    <header>
        <h1>Web Application Performance: Server-Side and Client-Side Optimization</h1>
    </header>

    <main>
        <article>
            <!-- Opening Quote -->
             <section id="opening-quote">
                <blockquote>
                    <p>
                        “Web performance has always been an important aspect of creating a website — numerous studies have shown the negative impact of a poorly performing website. 
                        With every additional second your website takes to load or respond to interactions, visitors leave, sales are lost, and engagement goes down.”
                    </p>
                    <cite>- Barry Pollard</cite>
                </blockquote>
            </section>

             <!-- Introduction -->
            <section>
                <p>Web performance refers primarily to the speed at which a website loads and responds to user interactions. 
                    We can break down web performance into two primary components:</p>
                    <ul>
                        <li>server-side performance</li>
                        <li> client-side (browser) performance</li>
                    </ul>
                <p>To understand this distinction, we'll explore how web performance optimization has evolved over different eras, examining both server-side and client-side approaches through the lens of an e-commerce website.</p>
            </section>

            <!-- Server-Side Evolution -->
            <section>
                <h2>Server-Side Performance</h2>
                <p>Server-side performance focuses on optimizing how the server processes requests and delivers content to clients.</p>
                <section>
                    <h3>Static File Servers (1990s)</h3>
                    <p> With traditional server-side design each request for a new view (HTML page) results in a round-trip to the server</p>
                    <div class="image-container">
                        <img src="assets/LAMP-stack.png" alt="traditional server-side design" width="393" height="564" >
                    </div>
                    <ul>
                        <li>Simple Apache/NGINX configurations serving static HTML</li>
                        <li>File-based content management</li>
                        <li>Basic server resource allocation</li>
                        <li>High initial infrastructure costs - startups needed significant capital for servers</li>
                    </ul>
                    <h4>E-commerce Example</h4>
                    <p>Product catalogs were static HTML files, manually updated for each product change. Companies needed to purchase and maintain their own servers, often requiring dedicated server rooms and IT staff.</p>
                </section>
                <section>
                    <h3>Dynamic Processing Era (Early-Mid 2000s)</h3>
                    <ul>
                        <li>Introduction of PHP, ASP, and CGI processing. The LAMP stack.</li>
                        <li>Basic database integrations (MySQL, PostgreSQL)</li>
                        <li>File-based caching mechanisms</li>
                        <li>Dedicated hosting providers emerge, but still required significant upfront investment</li>
                    </ul>
                </section>
                <section>
                    <h3>Cloud Revolution Era (2006-2010)</h3>
                    <p>see "The Cloud at Your Service: The when, how, and why of enterprise cloud computing" by Jothy Rosenberg and Arthur Mateos from 2010</p>
                    <ul>
                        <li>Amazon Web Services launches EC2 (2006), marking the beginning of modern cloud computing</li>
                        <li>Pay-as-you-go model emerges, drastically reducing startup infrastructure costs</li>
                        <li>Load balancing and server clustering becomes accessible</li>
                        <li>Memcached and distributed caching</li>
                        <li>Database optimization and sharding</li>
                    </ul>
                </section>
                <section>
                    <h3>Cloud Computing Era (2010s)</h3>
                    <ul>
                        <li>Auto-scaling infrastructure</li>
                        <li>CDN integration</li>
                        <li>Microservices architecture</li>
                    </ul>
                </section>
                <section>
                    <h3>Modern Era (Present)</h3>
                    <ul>
                        <li>Edge computing</li>
                        <li>Serverless architectures</li>
                        <li>AI-powered optimizations</li>
                    </ul>
                </section>
            </section>

            <!-- Client-Side Evolution -->
            <section>
                <h2>Client-Side Performance</h2>
                <p>Client-side performance concerns how quickly and smoothly the application runs in the user's browser.</p>
                <section>
                    <h3>Basic HTML Era (1990s)</h3>
                </section>
                <section>
                    <h3>Interactive Era (Early 2000s)</h3>
                </section>
                <section>
                    <h3>AJAX Revolution (Late 2000s)</h3>
                </section>
                <section>
                    <h3>Single Page Applications (2010s)</h3>
                </section>
                <section>
                    <h3>Modern Era (2015-Present)</h3>
                    <ul>
                        <li>Progressive Web Apps (PWAs) - Introduced by Google in 2015</li>
                        <li>Web Components and Shadow DOM</li>
                        <li>WebAssembly for high-performance code</li>
                        <li>JAMStack (JavaScript, APIs, and Markup) - Popularized around 2016</li>
                        <li>Headless architecture separating frontend from backend</li>
                        <li>Isomorphic/Universal JavaScript applications</li>
                    </ul>
                </section>
            </section>

            <!-- Convergence and Future -->
             <section>
                <h2>Convergence of Server and Client Optimization</h2>
                <section>
                    <h3>Current Best Practices</h3>
                    <ul>
                        <li>Edge computing with client-side hydration</li>
                        <li>Streaming server responses with progressive enhancement</li>
                        <li>Real-time data synchronization</li>
                        <li>Predictive resource loading</li>
                    </ul>
                </section>
                <section>
                    <h3>Future Trends</h3>
                    <ul>
                        <li>AI-driven performance optimization</li>
                        <li>Advanced caching strategies</li>
                        <li>Enhanced browser capabilities</li>
                        <li>New web standards and APIs</li>
                    </ul>
                </section>
             </section>

             <!-- Monitoring and Measurement -->
              <section>
                <h2>Performance Monitoring Evolution</h2>
                <section>
                    <h3>Server-Side Metrics</h3>
                    <ul>
                        <li>Response time tracking</li>
                        <li>Server resource utilization</li>
                        <li>Database performance metrics</li>
                        <li>API response times</li>
                    </ul>
                </section>
                <section>
                    <h3>Client-Side Metrics</h3>
                    <ul>
                        <li>Core Web Vitals</li>
                        <li>User-centric performance metrics</li>
                        <li>Real User Monitoring (RUM)</li>
                        <li>Synthetic testing results</li>
                    </ul>
                </section>
              </section>


              <!-- Conclusion -->
            <section>
                <h2>Conclusion</h2>
                <p>The parallel evolution of server-side and client-side optimization reflects the web's journey from simple document delivery to complex application platform. Understanding these separate but interrelated histories helps developers make better decisions about performance optimization strategies.</p>
                <p>As we move forward, the lines between server and client continue to blur, with technologies like edge computing and WebAssembly creating new opportunities for performance optimization at both ends of the web application stack.</p>
                <p>However, it's crucial to recognize that performance is an elusive goal—there is always room for a little more optimization—and we have to adopt a pragmatic approach to getting "good enough" performance. This means making informed decisions about where to focus optimization efforts, understanding the trade-offs involved, and recognizing when diminishing returns suggest it's time to move on to other priorities.</p>
            </section>
        </article>
    </main>
</body>
</html>